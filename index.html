    // --- 核心物理交互邏輯 ---
    const mouse = Mouse.create(container);
    // 加入這段，讓 Matter.js 支援手機觸控
    mouse.element.removeEventListener("mousewheel", mouse.mousewheel);
    mouse.element.removeEventListener("DOMMouseScroll", mouse.mousewheel);

    const mouseConstraint = MouseConstraint.create(engine, {
        mouse: mouse,
        constraint: {
            stiffness: 0.15, // 調整拉動的柔韌度
            render: { visible: false }
        }
    });
    
    Composite.add(engine.world, mouseConstraint);

    // 關鍵：修正手機觸控偏移問題
    let dragStart = null;
    let isDragging = false;

    Matter.Events.on(mouseConstraint, 'mousedown', (e) => {
        dragStart = { x: e.mouse.position.x, y: e.mouse.position.y };
        isDragging = false; 
    });

    Matter.Events.on(mouseConstraint, 'mousemove', (e) => {
        if (dragStart) {
            const dist = Vector.magnitude(Vector.sub(dragStart, e.mouse.position));
            if (dist > 5) isDragging = true; // 如果移動超過 5 像素，判定為拖拽
        }
    });

    Matter.Events.on(mouseConstraint, 'mouseup', (e) => {
        // 如果只是輕輕一點（沒拖拽），就執行存檔
        if (!isDragging && mouseConstraint.body) {
            const label = mouseConstraint.body.label;
            if (label !== 'Rectangle Body') saveActivity(label); 
        }
        dragStart = null;
        isDragging = false;
    });

    // 強化的向心力與視覺同步
    function update() {
        const center = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        bubbleBodies.forEach(body => {
            // 只有在沒被你抓著的時候，才會緩緩向中心靠攏
            if (mouseConstraint.body !== body) {
                const force = Vector.mult(Vector.normalise(Vector.sub(center, body.position)), 0.0004 * body.mass);
                Matter.Body.applyForce(body, body.position, force);
            }

            // 同步 DOM 位置
            body.element.style.transform = `translate(${body.position.x - body.circleRadius}px, ${body.position.y - body.circleRadius}px)`;
        });
        requestAnimationFrame(update);
    }
