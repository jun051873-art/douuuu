        // --- 核心物理交互邏輯 (手機觸控優化版) ---
    const mouse = Mouse.create(container);
    
    // 關鍵：這行能讓手機網頁「放開控制權」，交給物理引擎處理觸控
    mouse.element.removeEventListener("touchstart", mouse.touchstart);
    mouse.element.removeEventListener("touchmove", mouse.touchmove);
    mouse.element.removeEventListener("touchend", mouse.touchend);

    const mouseConstraint = MouseConstraint.create(engine, {
        mouse: mouse,
        constraint: {
            stiffness: 0.1, // 讓拉動感覺更有彈性
            render: { visible: false }
        }
    });
    
    Composite.add(engine.world, mouseConstraint);

    // 邏輯區分：是想「推開氣泡」還是「點擊存檔」？
    let startPoint = null;
    let moved = false;

    Matter.Events.on(mouseConstraint, 'mousedown', (e) => {
        startPoint = { x: e.mouse.position.x, y: e.mouse.position.y };
        moved = false;
    });

    Matter.Events.on(mouseConstraint, 'mousemove', (e) => {
        if (startPoint) {
            const distance = Vector.magnitude(Vector.sub(startPoint, e.mouse.position));
            if (distance > 10) moved = true; // 移動超過10像素，判定為「推」
        }
    });

    Matter.Events.on(mouseConstraint, 'mouseup', (e) => {
        // 如果手指只是輕點且沒滑動，才執行存檔
        if (!moved && mouseConstraint.body) {
            const actionText = mouseConstraint.body.label;
            // 排除掉中心黑洞或其他非標籤物體
            if (actionText && actionText !== 'Rectangle Body') {
                saveActivity(actionText);
            }
        }
        startPoint = null;
    });

    
    Composite.add(engine.world, mouseConstraint);

    // 關鍵：修正手機觸控偏移問題
    let dragStart = null;
    let isDragging = false;

    Matter.Events.on(mouseConstraint, 'mousedown', (e) => {
        dragStart = { x: e.mouse.position.x, y: e.mouse.position.y };
        isDragging = false; 
    });

    Matter.Events.on(mouseConstraint, 'mousemove', (e) => {
        if (dragStart) {
            const dist = Vector.magnitude(Vector.sub(dragStart, e.mouse.position));
            if (dist > 5) isDragging = true; // 如果移動超過 5 像素，判定為拖拽
        }
    });

    Matter.Events.on(mouseConstraint, 'mouseup', (e) => {
        // 如果只是輕輕一點（沒拖拽），就執行存檔
        if (!isDragging && mouseConstraint.body) {
            const label = mouseConstraint.body.label;
            if (label !== 'Rectangle Body') saveActivity(label); 
        }
        dragStart = null;
        isDragging = false;
    });

    // 強化的向心力與視覺同步
    function update() {
        const center = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        bubbleBodies.forEach(body => {
            // 只有在沒被你抓著的時候，才會緩緩向中心靠攏
            if (mouseConstraint.body !== body) {
                const force = Vector.mult(Vector.normalise(Vector.sub(center, body.position)), 0.0004 * body.mass);
                Matter.Body.applyForce(body, body.position, force);
            }

            // 同步 DOM 位置
            body.element.style.transform = `translate(${body.position.x - body.circleRadius}px, ${body.position.y - body.circleRadius}px)`;
        });
        requestAnimationFrame(update);
    }
